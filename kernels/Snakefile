configfile: "default.yaml"


C_VARIANTS = [
    "baseline",  # naive c
    "snrt",  # optimized c + inline asm for snitch festures
    "fused",  # optimized c + inline asm for snitch festures with manual fusion of reduction/elementwise loop nests
]

XDSL_VARIANTS = [
    "linalg_xdsl",
    "snitch_stream",
    "riscv_scf",
    "linalg_full_xdsl",  # should run the same passes as linalg_xdsl but via a fully expanded pipeline instead of xdsl-opt test passes/mini-pipelines
    "linalg_0_xdsl",  # incremental insertion of xDSL passes
    "linalg_1_xdsl",  # incremental insertion of xDSL passes
    "linalg_2_xdsl",  # incremental insertion of xDSL passes
    "linalg_3_xdsl",  # incremental insertion of xDSL passes
    "linalg_4_xdsl",  # incremental insertion of xDSL passes
]

MLIR_VARIANTS = [
    "linalg",  # naive mlir lowering from linalg on tensors
    "scf",  # naive mlir lowering from scf on memrefs
]

###########################################################
# Templated kernels, sources and data need to be
# generated on the fly
###########################################################

# Regular expressions to parse test shape (e.g.: 4x8xf64)
# Make sure dimensions in code match capture group names below:
SHAPE_2D = r"(?P<M>\d+)x(?P<N>\d+)xf(?P<precision>\d+)"
SHAPE_3D = r"(?P<M>\d+)x(?P<K>\d+)x(?P<N>\d+)xf(?P<precision>\d+)"

# Shape regex for each kernel
# Beware: the presence in the following dict makes the kernel
# a templated kernel. Dict keys below are used to enable
# source/data generation rules.
KERNEL_SHAPE = {
    "dsum": SHAPE_2D,
    "relu": SHAPE_2D,
    "fill": SHAPE_2D,
    "conv2d_d1_s1_3x3": SHAPE_2D,
    "pooling_nchw_sum_d1_s2_3x3": SHAPE_2D,
    "pooling_nchw_max_d1_s2_3x3": SHAPE_2D,
    "matmul": SHAPE_3D,
    "matmul_transb": SHAPE_3D,
}

KERNEL_TEMPLATES = KERNEL_SHAPE.keys()

# Common values to be added to params.json
PARAMS = {
    "rmin": -1000.0,
    "rmax": 1000.0,
}

###########################################################
# Manual kernels, sources and data provided as inputs
###########################################################

MANUAL_KERNELS = [
    *expand("saxpy/64xf32/{variant}", variant=["baseline", "snrt", "linalg"]),
    *expand(
        "ddot/128xf64/{variant}",
        variant=["baseline", "snrt", "snitch_stream", "linalg", "riscv_scf", "scf"],
    ),
    *expand(
        "dense/8x8xf64/{variant}",
        variant=["baseline", "snrt", "snitch_stream", "linalg", "fused"],
    ),
]

###########################################################
# Test sets
###########################################################

# Minimum set of tests to be used as a meaningful smoke test,
# runs as fast as possible to save CI time
TESTSET_FAST = [
    *MANUAL_KERNELS,
    # 3d templated kernels
    *expand("matmul_transb/4x16x16xf32/{variant}", variant=["baseline", "snrt"]),
    *expand(
        "matmul/4x16x8xf64/{variant}",
        variant=["baseline", "linalg_xdsl"],
    ),
    # 2d templated kernels: baseline + linalg_xdsl
    *expand(
        "{kernel}/4x4xf64/{variant}",
        kernel=[
            "dsum",
            "fill",
            "relu",
            "pooling_nchw_sum_d1_s2_3x3",
            "pooling_nchw_max_d1_s2_3x3",
            "conv2d_d1_s1_3x3",
        ],
        variant=["baseline", "linalg_xdsl"],
    ),
]

# Full set. Contains all tests needed by plots in the paper. Beware: it's huge.
TESTSET_ALL = [
    *MANUAL_KERNELS,
    # 3d templated kernels: baseline + linalg_xdsl
    *expand(
        "matmul/{M}x{K}x{N}xf64/{variant}",
        M=[4, 8],
        K=range(4, 65, 4),
        N=range(4, 65, 4),
        variant=["baseline", "linalg_xdsl"],
    ),
    # Passes contributions
    "matmul/1x400x25xf64/linalg_xdsl",
    "matmul/1x400x25xf64/linalg_full_xdsl",
    *expand("matmul/1x400x25xf64/linalg_{phase}_xdsl", phase=range(0, 5)),
    # 2d templated kernels: baseline + linalg_xdsl
    *expand(
        "{kernel}/{M}x{N}xf64/{variant}",
        kernel=[
            "dsum",
            "fill",
            "relu",
            "pooling_nchw_sum_d1_s2_3x3",
            "pooling_nchw_max_d1_s2_3x3",
            "conv2d_d1_s1_3x3",
        ],
        M=[4, 8, 12, 16],
        N=[4, 8, 12, 16],
        variant=["baseline", "linalg_xdsl"],
    ),
]


# Return the list of expected Verilator output files according to the
# selected 'testset' output wildcard
def select_test_set(wildcards) -> list[str]:
    if wildcards.testset == "fast":
        return expand("{test}.profile.json", test=TESTSET_FAST)
    if wildcards.testset == "all":
        return expand("{test}.profile.json", test=TESTSET_ALL)
    raise ValueError(
        f"unknown test set name '{wildcards.testset}', valid values are: fast, all"
    )


###########################################################
# Target rules
###########################################################


rule fast:
    input:
        "kernels.fast.csv",
        "pivoted.fast.csv",
        "pivoted_fpu.fast.csv",
        "pivoted_ipc.fast.csv",
    # This is the default rule taking over former result
    # file names:
    output:
        "kernels.csv",
        "pivoted.csv",
        "pivoted_fpu.csv",
        "pivoted_ipc.csv",
    shell:
        """
        cp -f kernels.fast.csv kernels.csv
        cp -f pivoted.fast.csv pivoted.csv
        cp -f pivoted_fpu.fast.csv pivoted_fpu.csv
        cp -f pivoted_ipc.fast.csv pivoted_ipc.csv
        """


rule all:
    input:
        "kernels.all.csv",
        "pivoted.all.csv",
        "pivoted_fpu.all.csv",
        "pivoted_ipc.all.csv",


###########################################################
# Rules
###########################################################


rule csv_to_pivoted:
    input:
        "kernels.{testset}.csv",
    output:
        "pivoted.{testset}.csv",
        "pivoted_fpu.{testset}.csv",
        "pivoted_ipc.{testset}.csv",
    params:
        pivot=config["root"] + "/scripts/pivot.py",
    shell:
        """
        {params.pivot} --outdir {resources.tmpdir} < {input}
        mv -f {resources.tmpdir}/pivoted.csv pivoted.{wildcards.testset}.csv
        mv -f {resources.tmpdir}/pivoted_fpu.csv pivoted_fpu.{wildcards.testset}.csv
        mv -f {resources.tmpdir}/pivoted_ipc.csv pivoted_ipc.{wildcards.testset}.csv
        """


rule profile_to_csv:
    input:
        select_test_set,
    output:
        "kernels.{testset}.csv",
    params:
        profile_to_csv=config["root"] + "/scripts/profile_to_csv.py",
    shell:
        "{params.profile_to_csv} {input} -o {output}"


rule trace_to_profile:
    input:
        txt="{kernel}/{shape}/{variant}.logs/trace_hart_00000000.trace.txt",
        json="{kernel}/{shape}/{variant}.logs/trace_hart_00000000.trace.json",
    output:
        "{kernel}/{shape}/{variant}.profile.json",
    params:
        trace_to_profile=config["root"] + "/scripts/trace_to_profile.py",
    shell:
        """
        {params.trace_to_profile} --section 1 \
          --add section 1 \
          --add test {wildcards.kernel} \
          --add params {wildcards.shape} \
          --add impl {wildcards.variant} \
          -o {output} {input.txt} {input.json}
        """


rule dasm_to_trace:
    input:
        "{test}.logs/trace_hart_00000000.dasm",
    output:
        txt="{test}.logs/trace_hart_00000000.trace.txt",
        json="{test}.logs/trace_hart_00000000.trace.json",
    params:
        spike=config["spike"],
        gentrace=config["gentrace"],
    shell:
        "{params.spike} < {input} | {params.gentrace} --permissive -d {output.json} > {output.txt}"


rule verilator:
    input:
        "{test}.x",
    output:
        expand("{{test}}.logs/trace_hart_0000000{hart}.dasm", hart=range(9)),
    params:
        workdir="{test}.logs",
        vltsim=config["vltsim"],
    shell:
        """
        mkdir -p {params.workdir}/logs
        cd {params.workdir}
        {params.vltsim} ../$(basename {input})
        mv -f logs/* .
        rm -fr logs
        """


# Build rules


rule cc_link:
    input:
        "{kernel}/{shape}/{variant}.o",
        "{kernel}/{shape}/data.o",
        "{kernel}/{shape}/main.o",
    output:
        "{kernel}/{shape}/{variant}.x",
    params:
        cc=config["cc"],
        ldflags=config["ldflags"],
    shell:
        "{params.cc} {params.ldflags} -o {output} {input}"


rule cc_assemble:
    input:
        "{source}.S",
    output:
        "{source}.o",
    params:
        cc=config["cc"],
        asflags=config["asflags"],
    shell:
        "{params.cc} {params.asflags} -c -o {output} {input}"


rule mlir_linalg_compile:
    input:
        "{source}.mlir",
    output:
        "{source}.ll",
    params:
        xdsl_opt=config["xdsl-opt"],
        mlir_opt=config["mlir-opt"],
        mlir_translate=config["mlir-translate"],
        mlir_opt_flags_linalg=config["mlir-opt-flags-linalg"],
        mlir_opt_flags_scf=config["mlir-opt-flags-scf"],
        tollvm12=config["root"] + "/snitch/tollvm12.py",
    shell:
        """
        {params.mlir_opt} {params.mlir_opt_flags_linalg} {input} \
        | sed 's/arith.maxf/arith.maximumf/g' \
        | {params.xdsl_opt} -p arith-add-fastmath \
        | sed 's/arith.maximumf/arith.maxf/g' \
        | {params.mlir_opt} {params.mlir_opt_flags_scf} \
        | {params.mlir_translate} -opaque-pointers=0 --mlir-to-llvmir \
        | {params.tollvm12} > {output}
        """


###########################################################
# Assembly rules
# Beware: all of the following rules are potentially
# ambiguous since they all produce a .S file.
# To discriminate, we constrain the kernel variant.
###########################################################


rule cc_compile_c:
    input:
        c="{kernel}/{shape}/{variant}.c",
        h="{kernel}/{shape}/data.h",
    output:
        "{kernel}/{shape}/{variant}.S",
    wildcard_constraints:
        variant="|".join(["data", "main"] + C_VARIANTS),
    params:
        cc=config["cc"],
        cflags=config["cflags"],
    shell:
        "{params.cc} -I$(dirname {input}) -I$(dirname {output}) {params.cflags} -S -o {output} {input.c}"


rule cc_compile_ll:
    input:
        "{kernel}/{shape}/{variant}.ll",
    output:
        "{kernel}/{shape}/{variant}.S",
    wildcard_constraints:
        variant="|".join(MLIR_VARIANTS),
    params:
        cc=config["cc"],
        cflags=config["cflags"],
    shell:
        "{params.cc} {params.cflags} -S -o {output} {input}"


def filter_xdsl_pipeline_passes(wildcards):
    import re

    if wildcards.variant == "linalg_full_xdsl":
        return ",".join(config["xdsl-passes"])

    match = re.search(r"linalg_(\d)_xdsl", wildcards.variant)
    if not match:
        return ",".join(config["xdsl-test-passes"])

    passes = [
        "memref-stream-tile-outer-loops",
        "memref-stream-unnest-out-parameters",
        "memref-stream-interleave",
        "memref-streamify",
        "convert-riscv-scf-for-to-frep",
        # FIXME cannot reconcile unrealized casts
        # "convert-linalg-to-memref-stream",
    ]

    level = int(match.group(1))
    if level < 0 or level >= len(passes):
        raise ValueError(
            f"xDSL linalg incremental pipeline level must be in range [0, {len(passes)})"
        )
    keep = set(passes[:level])
    to_be_removed = [p for p in passes if p not in keep]
    print(f"{match.group(0)}: removing xdsl passes: {to_be_removed}")
    pattern = re.compile("|".join(to_be_removed))
    pipeline = [p for p in config["xdsl-passes"] if not pattern.search(p)]
    return ",".join(pipeline)


rule xdsl_compile:
    input:
        "{kernel}/{shape}/{variant}.xdsl.mlir",
    output:
        "{kernel}/{shape}/{variant}.S",
    wildcard_constraints:
        variant="|".join(XDSL_VARIANTS),
    params:
        xdsl_opt=config["xdsl-opt"],
        passes=filter_xdsl_pipeline_passes,
    shell:
        """
        sed 's/arith.maxf/arith.maximumf/g' {input} \
        | {params.xdsl_opt} -p {params.passes} -t riscv-asm -o {output}
        """


# Specific rules for shared source files,
# a.k.a. where the input source is in another directory WRT output


rule cc_compile_shared_main:
    input:
        c="{kernel}/main.c",
        h="{kernel}/{shape}/data.h",
    output:
        "{kernel}/{shape}/main.S",
    params:
        cc=config["cc"],
        cflags=config["cflags"],
    shell:
        "{params.cc} -I$(dirname {input.h}) {params.cflags} -S -o {output} {input.c}"


###########################################################
# Sources/data generation rules, restricted to templated
# kernels only
###########################################################


rule kernel_generate_params:
    output:
        "{kernel}/{shape}/params.json",
    wildcard_constraints:
        kernel="|".join(KERNEL_TEMPLATES),
    run:
        import re
        import json

        pattern = re.compile(KERNEL_SHAPE[wildcards.kernel])
        match = pattern.fullmatch(wildcards.shape)
        assert match
        params = {k: int(v) for k, v in match.groupdict().items()}
        params.update(PARAMS)
        with open(output[0], "w") as out:
            json.dump(params, out, indent=4)


rule kernel_generate_data_h:
    input:
        json="{kernel}/{shape}/params.json",
        template="{kernel}/data.h.template",
    output:
        "{kernel}/{shape}/data.h",
    wildcard_constraints:
        kernel="|".join(KERNEL_TEMPLATES),
    params:
        format_template=config["root"] + "/scripts/format.py",
    shell:
        "python3 {params.format_template} {input.template} {input.json} > {output}"


rule kernel_generate_data_c:
    input:
        json="{kernel}/{shape}/params.json",
        h="{kernel}/{shape}/data.h",
    output:
        "{kernel}/{shape}/data.c",
    wildcard_constraints:
        kernel="|".join(KERNEL_TEMPLATES),
    shell:
        "python3 -m {wildcards.kernel}.gendata -p {input.json} > {output}"


rule kernel_generate_source:
    input:
        json="{kernel}/{shape}/params.json",
        template="{kernel}/{variant}.{ext}.template",
    output:
        "{kernel}/{shape}/{variant}.{ext}",
    wildcard_constraints:
        ext="c|mlir",
        kernel="|".join(KERNEL_TEMPLATES),
    params:
        format_template=config["root"] + "/scripts/format.py",
    shell:
        "python3 {params.format_template} {input.template} {input.json} > {output}"


rule xdsl_kernel_generate_source:
    input:
        json="{kernel}/{shape}/params.json",
        template="{kernel}/linalg.mlir.template",
    output:
        "{kernel}/{shape}/{variant}.xdsl.mlir",
    wildcard_constraints:
        kernel="|".join(KERNEL_TEMPLATES),
    params:
        format_template=config["root"] + "/scripts/format.py",
        xdsl_opt=config["xdsl-opt"],
        mlir_opt=config["mlir-opt"],
        mlir_opt_flags_linalg=config["mlir-opt-flags-linalg"],
    shell:
        """
        python3 {params.format_template} {input.template} {input.json} \
        | {params.mlir_opt} {params.mlir_opt_flags_linalg} \
        | sed 's/arith.maxf/arith.maximumf/g' \
        | {params.xdsl_opt} -p arith-add-fastmath \
        | sed 's/arith.maximumf/arith.maxf/g' > {output}
        """
